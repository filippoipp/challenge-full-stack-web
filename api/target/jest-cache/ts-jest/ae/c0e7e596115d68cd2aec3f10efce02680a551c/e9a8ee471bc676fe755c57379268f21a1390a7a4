[["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/middlewares/validation.test.ts",{"fileContent":"import crypto from 'crypto';\r\n\r\nimport Joi from '@hapi/joi';\r\nimport { getMockReq, getMockRes } from '@jest-mock/express';\r\n\r\nimport HttpError from '../errors/http-error';\r\nimport {\r\n  validateBody, validateParams, validateQuery, validateRequest,\r\n} from './validation';\r\n\r\nconst keycloakRequest = Joi.object({\r\n  keycloakTokenModel: Joi.object({\r\n    idAccount: Joi.string().required(),\r\n  }).required(),\r\n});\r\n\r\nconst anyParams = Joi.object({\r\n  idAccount: Joi.string().required(),\r\n});\r\n\r\nconst anyBody = Joi.object({\r\n  idAccount: Joi.string().required(),\r\n});\r\n\r\nconst fakeValue = () => crypto.randomBytes(32).toString('hex');\r\n\r\ndescribe('Test validation middleware', () => {\r\n  test('Should call next with error when called validateRequest with object empty', async () => {\r\n    const mockRequest = getMockReq({\r\n      keycloakTokenModel: {},\r\n    });\r\n\r\n    const httpError = new HttpError(422, 'SERVER-422', 'Validation error', [\r\n      { idAccount: 'keycloakTokenModel.idAccount is required' },\r\n    ]);\r\n\r\n    const { res, next } = getMockRes();\r\n\r\n    const middleware = validateRequest(keycloakRequest);\r\n    await middleware(mockRequest, res, next);\r\n\r\n    expect(next).toHaveBeenCalledTimes(1);\r\n    expect(next).toHaveBeenCalledWith(httpError);\r\n  });\r\n\r\n  test('Should call next with error when called validateRequest with object undefined', async () => {\r\n    const mockRequest = getMockReq({\r\n      keycloakTokenModel: undefined,\r\n    });\r\n\r\n    const httpError = new HttpError(422, 'SERVER-422', 'Validation error', [\r\n      { idAccount: 'keycloakTokenModel is required' },\r\n    ]);\r\n\r\n    const { res, next } = getMockRes();\r\n\r\n    const middleware = validateRequest(keycloakRequest);\r\n    await middleware(mockRequest, res, next);\r\n\r\n    expect(next).toHaveBeenCalledTimes(1);\r\n    expect(next).toHaveBeenCalledWith(httpError);\r\n  });\r\n\r\n  test('Should call next with empty when called validateRequest with object valid', async () => {\r\n    const mockRequest = getMockReq({\r\n      keycloakTokenModel: {\r\n        idAccount: fakeValue(),\r\n      },\r\n    });\r\n\r\n    const { res, next } = getMockRes();\r\n\r\n    const middleware = validateRequest(keycloakRequest);\r\n    await middleware(mockRequest, res, next);\r\n\r\n    expect(next).toHaveBeenCalledTimes(1);\r\n    expect(next).toHaveBeenCalledWith();\r\n  });\r\n\r\n  test('Should call next with error when called validateParams with object empty', async () => {\r\n    const mockRequest = getMockReq({\r\n      params: {},\r\n    });\r\n\r\n    const httpError = new HttpError(422, 'SERVER-422', 'Validation error', [\r\n      { idAccount: 'idAccount is required' },\r\n    ]);\r\n\r\n    const { res, next } = getMockRes();\r\n\r\n    const middleware = validateParams(anyParams);\r\n    await middleware(mockRequest, res, next);\r\n\r\n    expect(next).toHaveBeenCalledTimes(1);\r\n    expect(next).toHaveBeenCalledWith(httpError);\r\n  });\r\n\r\n  test('Should call next with empty when called validateParams with object valid', async () => {\r\n    const mockRequest = getMockReq({\r\n      params: {\r\n        idAccount: fakeValue(),\r\n      },\r\n    });\r\n\r\n    const { res, next } = getMockRes();\r\n\r\n    const middleware = validateParams(anyParams);\r\n    await middleware(mockRequest, res, next);\r\n\r\n    expect(next).toHaveBeenCalledTimes(1);\r\n    expect(next).toHaveBeenCalledWith();\r\n  });\r\n\r\n  test('Should call next with error when called validateQuery with object empty', async () => {\r\n    const mockRequest = getMockReq({\r\n      query: {},\r\n    });\r\n\r\n    const httpError = new HttpError(422, 'SERVER-422', 'Validation error', [\r\n      { idAccount: 'idAccount is required' },\r\n    ]);\r\n\r\n    const { res, next } = getMockRes();\r\n\r\n    const middleware = validateQuery(anyParams);\r\n    await middleware(mockRequest, res, next);\r\n\r\n    expect(next).toHaveBeenCalledTimes(1);\r\n    expect(next).toHaveBeenCalledWith(httpError);\r\n  });\r\n\r\n  test('Should call next with empty when called validateQuery with object valid', async () => {\r\n    const mockRequest = getMockReq({\r\n      query: {\r\n        idAccount: fakeValue(),\r\n      },\r\n    });\r\n\r\n    const { res, next } = getMockRes();\r\n\r\n    const middleware = validateQuery(anyParams);\r\n    await middleware(mockRequest, res, next);\r\n\r\n    expect(next).toHaveBeenCalledTimes(1);\r\n    expect(next).toHaveBeenCalledWith();\r\n  });\r\n\r\n  test('Should call next with error when called validateBody with object empty', async () => {\r\n    const mockRequest = getMockReq({\r\n      body: {},\r\n    });\r\n\r\n    const httpError = new HttpError(422, 'SERVER-422', 'Validation error', [\r\n      { idAccount: 'idAccount is required' },\r\n    ]);\r\n\r\n    const { res, next } = getMockRes();\r\n\r\n    const middleware = validateBody(anyBody);\r\n    await middleware(mockRequest, res, next);\r\n\r\n    expect(next).toHaveBeenCalledTimes(1);\r\n    expect(next).toHaveBeenCalledWith(httpError);\r\n  });\r\n\r\n  test('Should call next with empty when called validateBody with object valid', async () => {\r\n    const mockRequest = getMockReq({\r\n      body: {\r\n        idAccount: fakeValue(),\r\n      },\r\n    });\r\n\r\n    const { res, next } = getMockRes();\r\n\r\n    const middleware = validateBody(anyBody);\r\n    await middleware(mockRequest, res, next);\r\n\r\n    expect(next).toHaveBeenCalledTimes(1);\r\n    expect(next).toHaveBeenCalledWith();\r\n  });\r\n});\r\n","resolvedModuleNames":["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/http-error.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/middlewares/validation.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/default-error.ts"]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/http-error.ts",{"fileContent":"import DefaultError from './default-error';\r\n\r\nexport default class HttpError extends DefaultError {\r\n  public statusCode: number = null;\r\n\r\n  public report: any = null;\r\n\r\n  constructor(statusCode: number, errorCode: string, message: string, report: any, error?: Error) {\r\n    super(message, errorCode, error);\r\n\r\n    this.statusCode = statusCode;\r\n    this.report = report?.response ? { ...report.response } : report;\r\n  }\r\n}\r\n","resolvedModuleNames":["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/default-error.ts"]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/default-error.ts",{"fileContent":"export default class DefaultError extends Error {\r\n  public code: string = null;\r\n\r\n  constructor(message: string, code: string, error?: Error) {\r\n    super(message);\r\n\r\n    Error.captureStackTrace(this, this.constructor);\r\n    this.name = this.constructor.name;\r\n    if (error && error.stack) {\r\n      this.stack = `${this.stack}\\n${error.stack.substring(error.stack.indexOf('\\n') + 1)}`;\r\n    }\r\n    this.code = code;\r\n  }\r\n}\r\n","resolvedModuleNames":[]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/middlewares/validation.ts",{"fileContent":"import { NextFunction, Request, Response } from 'express';\r\nimport { AnySchema } from '@hapi/joi';\r\nimport HttpError from '../errors/http-error';\r\n\r\nasync function checkAndReturnValidationResult(schema: AnySchema, data: any, joiConfig = {}) {\r\n  const { error, value: sanitizedData } = schema.validate(data, {\r\n    abortEarly: false,\r\n    allowUnknown: true,\r\n    ...joiConfig,\r\n  });\r\n\r\n  if (!error) {\r\n    return sanitizedData;\r\n  }\r\n\r\n  const report = error.details.map((detail) => {\r\n    const key = detail.path.join('.');\r\n    const message = detail.message.replace(/['\"]/g, '');\r\n    return { [key]: message };\r\n  });\r\n\r\n  throw new HttpError(422, 'SERVER-422', 'Validation error', report);\r\n}\r\n\r\nconst validateRequest = (joiSchema: AnySchema) => async (req: Request, res: Response, next: NextFunction) => {\r\n  try {\r\n    await checkAndReturnValidationResult(joiSchema, req);\r\n    next();\r\n  } catch (err) {\r\n    next(err);\r\n  }\r\n};\r\n\r\nconst validateParams = (joiSchema: AnySchema) => async (req: Request, res: Response, next: NextFunction) => {\r\n  try {\r\n    const { params } = req;\r\n    await checkAndReturnValidationResult(joiSchema, params, {\r\n      stripUnknown: true,\r\n    });\r\n    req.params = params;\r\n    next();\r\n  } catch (err) {\r\n    next(err);\r\n  }\r\n};\r\n\r\nconst validateQuery = (joiSchema: AnySchema) => async (req: Request, res: Response, next: NextFunction) => {\r\n  try {\r\n    const { query } = req;\r\n    const result = await checkAndReturnValidationResult(joiSchema, query);\r\n    req.query = result;\r\n    next();\r\n  } catch (err) {\r\n    next(err);\r\n  }\r\n};\r\n\r\nconst validateBody = (joiSchema: AnySchema) => async (req: Request, res: Response, next: NextFunction) => {\r\n  try {\r\n    const { body } = req;\r\n    await checkAndReturnValidationResult(joiSchema, body, {\r\n      stripUnknown: true,\r\n    });\r\n    req.body = body;\r\n    next();\r\n  } catch (err) {\r\n    next(err);\r\n  }\r\n};\r\n\r\nexport {\r\n  validateBody, validateParams, validateQuery, validateRequest,\r\n};\r\n","resolvedModuleNames":["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/http-error.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/default-error.ts"]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/student/controller.spec.ts",{"fileContent":"import { getMockReq, getMockRes } from '@jest-mock/express';\nimport { faker } from '@faker-js/faker';\nimport Repository from './repository';\nimport controller from './controller';\nimport Student from './entities/student';\n\njest.mock('./repository');\n\nconst RepositoryMock = Repository as jest.MockedClass<typeof Repository>;\n\ndescribe('Test student controller', () => {\n  beforeEach(async () => {\n    RepositoryMock.prototype.createStudent.mockRestore();\n    RepositoryMock.prototype.listStudents.mockRestore();\n    RepositoryMock.prototype.updateStudent.mockRestore();\n    RepositoryMock.prototype.deleteStudent.mockRestore();\n  });\n\n  test('Should response 200 when call listStudents with sucess', async () => {\n    const mockRequest = getMockReq();\n\n    const studentsMock: Student[] = [\n      {\n        id: faker.datatype.uuid(),\n        name: faker.internet.userName(),\n        email: faker.internet.email(),\n        ra: faker.datatype.string(),\n        cpf: faker.datatype.string(),\n        createdAt: faker.datatype.datetime(),\n        updatedAt: faker.datatype.datetime(),\n      },\n      {\n        id: faker.datatype.uuid(),\n        name: faker.internet.userName(),\n        email: faker.internet.email(),\n        ra: faker.datatype.string(),\n        cpf: faker.datatype.string(),\n        createdAt: faker.datatype.datetime(),\n        updatedAt: faker.datatype.datetime(),\n      },\n    ];\n\n    const { res, next } = getMockRes();\n\n    RepositoryMock.prototype.listStudents.mockResolvedValue(studentsMock);\n\n    await controller.listStudents(mockRequest, res, next);\n\n    expect(RepositoryMock.prototype.listStudents).toBeCalledTimes(1);\n    expect(RepositoryMock.prototype.listStudents).toBeCalledWith();\n    expect(res.status).toBeCalledTimes(1);\n    expect(res.status).toBeCalledWith(200);\n    expect(res.json).toBeCalledTimes(1);\n    expect(next).toBeCalledTimes(0);\n  });\n\n  test('Should return error when call getUser with exception', async () => {\n    const mockRequest = getMockReq();\n\n    const mockError = new Error('Any Error.');\n\n    const { res, next } = getMockRes();\n\n    RepositoryMock.prototype.listStudents.mockRejectedValue(mockError);\n\n    await controller.listStudents(mockRequest, res, next);\n\n    expect(RepositoryMock.prototype.listStudents).toBeCalledTimes(1);\n    expect(res.status).not.toBeCalled();\n    expect(res.json).not.toBeCalled();\n    expect(next).toBeCalledTimes(1);\n    expect(next).toBeCalledWith(mockError);\n  });\n\n  test('Should response 201 when call createStudent with sucess', async () => {\n    const studentMock = {\n      name: faker.internet.userName(),\n      email: faker.internet.email(),\n      cpf: faker.datatype.string(),\n    };\n\n    const mockRequest = getMockReq({\n      body: studentMock,\n    });\n\n    const studentResponseMock: Student = {\n      name: studentMock.name,\n      email: studentMock.email,\n      cpf: studentMock.cpf,\n      ra: faker.datatype.string(),\n      id: faker.datatype.uuid(),\n      createdAt: faker.datatype.datetime(),\n      updatedAt: faker.datatype.datetime(),\n    };\n\n    const { res, next } = getMockRes();\n\n    RepositoryMock.prototype.createStudent.mockResolvedValue(studentResponseMock);\n\n    await controller.createStudent(mockRequest, res, next);\n\n    expect(RepositoryMock.prototype.createStudent).toBeCalledTimes(1);\n    expect(RepositoryMock.prototype.createStudent).toBeCalledWith(studentMock);\n    expect(res.status).toBeCalledTimes(1);\n    expect(res.status).toBeCalledWith(201);\n    expect(res.json).toBeCalledTimes(1);\n    expect(next).toBeCalledTimes(0);\n  });\n\n  test('Should return error when call createStudent with exception', async () => {\n    const mockRequest = getMockReq();\n\n    const mockError = new Error('Any Error.');\n\n    const { res, next } = getMockRes();\n\n    RepositoryMock.prototype.createStudent.mockRejectedValue(mockError);\n\n    await controller.createStudent(mockRequest, res, next);\n\n    expect(RepositoryMock.prototype.createStudent).toBeCalledTimes(1);\n    expect(res.status).not.toBeCalled();\n    expect(res.json).not.toBeCalled();\n    expect(next).toBeCalledTimes(1);\n    expect(next).toBeCalledWith(mockError);\n  });\n\n  test('Should response 204 when call deleteStudent with sucess', async () => {\n    const fakeStudentId = faker.datatype.uuid();\n\n    const mockRequest = getMockReq({\n      params: {\n        id: fakeStudentId,\n      },\n    });\n\n    const { res, next } = getMockRes();\n\n    RepositoryMock.prototype.deleteStudent.mockResolvedValue();\n\n    await controller.deleteStudent(mockRequest, res, next);\n\n    expect(RepositoryMock.prototype.deleteStudent).toBeCalledTimes(1);\n    expect(RepositoryMock.prototype.deleteStudent).toBeCalledWith(fakeStudentId);\n    expect(res.status).toBeCalledTimes(1);\n    expect(res.status).toBeCalledWith(204);\n    expect(res.json).toBeCalledTimes(1);\n    expect(next).toBeCalledTimes(0);\n  });\n\n  test('Should return error when call deleteStudent with exception', async () => {\n    const mockRequest = getMockReq();\n\n    const mockError = new Error('Any Error.');\n\n    const { res, next } = getMockRes();\n\n    RepositoryMock.prototype.deleteStudent.mockRejectedValue(mockError);\n\n    await controller.deleteStudent(mockRequest, res, next);\n\n    expect(RepositoryMock.prototype.deleteStudent).toBeCalledTimes(1);\n    expect(res.status).not.toBeCalled();\n    expect(res.json).not.toBeCalled();\n    expect(next).toBeCalledTimes(1);\n    expect(next).toBeCalledWith(mockError);\n  });\n\n  test('Should response 204 when call updateStudent with sucess', async () => {\n    const fakeStudentId = faker.datatype.uuid();\n\n    const mockRequest = getMockReq({\n      params: {\n        id: fakeStudentId,\n      },\n    });\n\n    const { res, next } = getMockRes();\n\n    RepositoryMock.prototype.updateStudent.mockResolvedValue();\n\n    await controller.updateStudent(mockRequest, res, next);\n\n    expect(RepositoryMock.prototype.updateStudent).toBeCalledTimes(1);\n    expect(RepositoryMock.prototype.updateStudent).toBeCalledWith({}, fakeStudentId);\n    expect(res.status).toBeCalledTimes(1);\n    expect(res.status).toBeCalledWith(204);\n    expect(res.json).toBeCalledTimes(1);\n    expect(next).toBeCalledTimes(0);\n  });\n\n  test('Should return error when call updateStudent with exception', async () => {\n    const mockRequest = getMockReq();\n\n    const mockError = new Error('Any Error.');\n\n    const { res, next } = getMockRes();\n\n    RepositoryMock.prototype.updateStudent.mockRejectedValue(mockError);\n\n    await controller.updateStudent(mockRequest, res, next);\n\n    expect(RepositoryMock.prototype.updateStudent).toBeCalledTimes(1);\n    expect(res.status).not.toBeCalled();\n    expect(res.json).not.toBeCalled();\n    expect(next).toBeCalledTimes(1);\n    expect(next).toBeCalledWith(mockError);\n  });\n});\n","resolvedModuleNames":["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/student/repository.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/student/controller.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/student/entities/student.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/student/index.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/http-error.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/student/interfaces/inputs/create-student-dto.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/student/interfaces/inputs/update-student-dto.ts"]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/student/repository.ts",{"fileContent":"import { getRepository } from 'typeorm';\nimport { studentErrorKeys, studentErrorMessages } from '../../errors/translator/student';\nimport HttpError from '../../errors/http-error';\nimport Student from './entities/student';\nimport CreateStudentRequest from './interfaces/inputs/create-student-dto';\nimport UpdateStudentRequest from './interfaces/inputs/update-student-dto';\n\nexport default class StudentRepository {\n  private async generateRa(): Promise<string> {\n    return `${new Date().getFullYear()}${Math.floor(Math.random() * 90000) + 10000}`;\n  }\n\n  public async createStudent(studentData: CreateStudentRequest): Promise<Student> {\n    try {\n      const studentRepository = getRepository(Student);\n      const student = await studentRepository.save({\n        ...studentData,\n        ra: await this.generateRa(),\n      });\n      return student;\n    } catch (error) {\n      throw new HttpError(\n        500,\n        studentErrorKeys.CREATE_STUDENT_FAIL,\n        studentErrorMessages[studentErrorKeys.CREATE_STUDENT_FAIL],\n        {},\n      );\n    }\n  }\n\n  public async listStudents(): Promise<Student[]> {\n    try {\n      const studentRepository = getRepository(Student);\n      const students = await studentRepository.find();\n      return students;\n    } catch (error) {\n      throw new HttpError(\n        500,\n        studentErrorKeys.GET_ALL_STUDENTS_FAIL,\n        studentErrorMessages[studentErrorKeys.GET_ALL_STUDENTS_FAIL],\n        {},\n      );\n    }\n  }\n\n  public async updateStudent(studentData: UpdateStudentRequest, studentId: string): Promise<void> {\n    try {\n      const studentRepository = getRepository(Student);\n      await studentRepository.update(studentId, studentData);\n    } catch (error) {\n      throw new HttpError(\n        500,\n        studentErrorKeys.UPDATE_STUDENT_FAIL,\n        studentErrorMessages[studentErrorKeys.UPDATE_STUDENT_FAIL],\n        {},\n      );\n    }\n  }\n\n  public async deleteStudent(studentId: string): Promise<void> {\n    try {\n      const studentRepository = getRepository(Student);\n      await studentRepository.delete(studentId);\n    } catch (error) {\n      throw new HttpError(\n        500,\n        studentErrorKeys.DELETE_STUDENT_FAIL,\n        studentErrorMessages[studentErrorKeys.DELETE_STUDENT_FAIL],\n        {},\n      );\n    }\n  }\n}\n","resolvedModuleNames":["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/student/index.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/http-error.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/student/entities/student.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/student/interfaces/inputs/create-student-dto.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/student/interfaces/inputs/update-student-dto.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/student/key.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/student/message.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/default-error.ts"]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/student/index.ts",{"fileContent":"import studentErrorKeys from './key';\nimport studentErrorMessages from './message';\n\nexport { studentErrorKeys, studentErrorMessages };\n","resolvedModuleNames":["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/student/key.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/student/message.ts"]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/student/key.ts",{"fileContent":"export default {\n  CREATE_STUDENT_FAIL: 'STUDENT-001',\n  DELETE_STUDENT_FAIL: 'STUDENT-002',\n  UPDATE_STUDENT_FAIL: 'STUDENT-003',\n  GET_ALL_STUDENTS_FAIL: 'STUDENT-005',\n};\n","resolvedModuleNames":[]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/student/message.ts",{"fileContent":"export default {\n  'STUDENT-001': 'Failed to create student.',\n  'STUDENT-002': 'Failed to delete student.',\n  'STUDENT-003': 'Failed to update student.',\n  'STUDENT-005': 'Failed to get all students.',\n};\n","resolvedModuleNames":[]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/student/entities/student.ts",{"fileContent":"import {\n  Entity,\n  CreateDateColumn,\n  UpdateDateColumn,\n  PrimaryGeneratedColumn,\n  Column,\n} from 'typeorm';\n\n@Entity('student')\nexport default class Student {\n  @PrimaryGeneratedColumn('uuid', { name: 'id' })\n  id: string;\n\n  @Column()\n  name: string;\n\n  @Column()\n  email: string;\n\n  @Column({ unique: true })\n  ra: string;\n\n  @Column()\n  cpf: string;\n\n  @CreateDateColumn({ name: 'created_at' })\n  createdAt: Date;\n\n  @UpdateDateColumn({ name: 'updated_at' })\n  updatedAt: Date;\n}\n","resolvedModuleNames":[]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/student/controller.ts",{"fileContent":"import { NextFunction, Request, Response } from 'express';\nimport StudentRepository from './repository';\n\nconst repository = new StudentRepository();\n\nasync function createStudent(req: Request, res: Response, next: NextFunction) {\n  try {\n    const response = await repository.createStudent(req.body);\n    res.status(201).json(response);\n  } catch (error) {\n    next(error);\n  }\n}\n\nasync function listStudents(req: Request, res: Response, next: NextFunction) {\n  try {\n    const response = await repository.listStudents();\n    res.status(200).json(response);\n  } catch (error) {\n    next(error);\n  }\n}\n\nasync function updateStudent(req: Request, res: Response, next: NextFunction) {\n  try {\n    const response = await repository.updateStudent(req.body, req.params.id);\n    res.status(204).json(response);\n  } catch (error) {\n    next(error);\n  }\n}\n\nasync function deleteStudent(req: Request, res: Response, next: NextFunction) {\n  try {\n    const response = await repository.deleteStudent(req.params.id);\n    res.status(204).json(response);\n  } catch (error) {\n    next(error);\n  }\n}\n\nexport default {\n  createStudent,\n  listStudents,\n  updateStudent,\n  deleteStudent,\n};\n","resolvedModuleNames":["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/student/repository.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/student/index.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/http-error.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/student/entities/student.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/student/interfaces/inputs/create-student-dto.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/student/interfaces/inputs/update-student-dto.ts"]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/config/app-config.test.ts",{"fileContent":"describe('Test app config', () => {\n  const { env } = process;\n\n  beforeEach(() => {\n    jest.resetModules();\n    process.env = env;\n  });\n\n  afterAll(() => {\n    process.env = env;\n  });\n\n  test('Should return the environment variable configuration SERVERS', async () => {\n    const Config = (await import('./app-config')).default;\n\n    expect(Config.SERVERS.http.hostname).toEqual('0.0.0.0');\n    expect(Config.SERVERS.http.port).toEqual(3001);\n  });\n\n  test('Should return the default configuration SERVERS', async () => {\n    process.env.HTTP_HOST = '';\n    process.env.HTTP_PORT = '';\n    const Config = (await import('./app-config')).default;\n\n    expect(Config.SERVERS.http.hostname).toEqual('0.0.0.0');\n    expect(Config.SERVERS.http.port).toEqual(3001);\n  });\n});\n","resolvedModuleNames":["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/config/app-config.ts"]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/config/app-config.ts",{"fileContent":"class Config {\n  public static ENVIRONMENT = process.env.ENVIRONMENT || 'dev';\n\n  public static SERVERS = {\n    http: {\n      hostname: process.env.HOST || '0.0.0.0',\n      port: Number(process.env.PORT) || 3001,\n    },\n  };\n}\n\nexport default Config;\n","resolvedModuleNames":[]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/controller.spec.ts",{"fileContent":"import { getMockReq, getMockRes } from '@jest-mock/express';\nimport { faker } from '@faker-js/faker';\nimport Repository from './repository';\nimport controller from './controller';\nimport User from './entities/user';\n\njest.mock('./repository');\n\nconst RepositoryMock = Repository as jest.MockedClass<typeof Repository>;\n\ndescribe('Test user controller', () => {\n  beforeEach(async () => {\n    RepositoryMock.prototype.createUser.mockRestore();\n  });\n\n  test('Should response 201 when call createUser with sucess', async () => {\n    const userMock = {\n      name: faker.internet.userName(),\n      email: faker.internet.email(),\n      password: faker.internet.password(),\n    };\n\n    const mockRequest = getMockReq({\n      body: userMock,\n    });\n\n    const userResponseMock = {\n      id: faker.datatype.uuid(),\n      name: userMock.name,\n      email: userMock.email,\n      createdAt: faker.datatype.datetime(),\n      updatedAt: faker.datatype.datetime(),\n    } as User;\n\n    const { res, next } = getMockRes();\n\n    RepositoryMock.prototype.createUser.mockResolvedValue(userResponseMock);\n\n    await controller.createUser(mockRequest, res, next);\n\n    expect(RepositoryMock.prototype.createUser).toBeCalledTimes(1);\n    expect(RepositoryMock.prototype.createUser).toBeCalledWith(userMock);\n    expect(res.status).toBeCalledTimes(1);\n    expect(res.status).toBeCalledWith(201);\n    expect(res.json).toBeCalledTimes(1);\n    expect(next).toBeCalledTimes(0);\n  });\n\n  test('Should return error when call createUser with exception', async () => {\n    const mockRequest = getMockReq();\n\n    const mockError = new Error('Any Error.');\n\n    const { res, next } = getMockRes();\n\n    RepositoryMock.prototype.createUser.mockRejectedValue(mockError);\n\n    await controller.createUser(mockRequest, res, next);\n\n    expect(RepositoryMock.prototype.createUser).toBeCalledTimes(1);\n    expect(res.status).not.toBeCalled();\n    expect(res.json).not.toBeCalled();\n    expect(next).toBeCalledTimes(1);\n    expect(next).toBeCalledWith(mockError);\n  });\n});\n","resolvedModuleNames":["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/repository.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/controller.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/entities/user.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/user/index.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/http-error.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/interfaces/inputs/create-user-dto.ts"]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/repository.ts",{"fileContent":"import { getRepository } from 'typeorm';\nimport { userErrorKeys, userErrorMessages } from '../../errors/translator/user';\nimport HttpError from '../../errors/http-error';\nimport User from './entities/user';\nimport CreateUserRequest from './interfaces/inputs/create-user-dto';\n\nexport default class UserRepository {\n  public async createUser(userData: CreateUserRequest): Promise<User> {\n    try {\n      const userRepository = getRepository(User);\n      const user = await userRepository.save(userRepository.create(userData));\n      delete user.password;\n\n      return user;\n    } catch (error) {\n      throw new HttpError(\n        500,\n        userErrorKeys.CREATE_USER_FAIL,\n        userErrorMessages[userErrorKeys.CREATE_USER_FAIL],\n        {},\n      );\n    }\n  }\n\n  public async findByEmail(email: string): Promise<User> {\n    try {\n      const userRepository = getRepository(User);\n      return await userRepository.findOne({\n        where: {\n          email,\n        },\n      });\n    } catch (error) {\n      throw new HttpError(\n        500,\n        userErrorKeys.FIND_USER_FAIL,\n        userErrorMessages[userErrorKeys.FIND_USER_FAIL],\n        {},\n      );\n    }\n  }\n}\n","resolvedModuleNames":["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/user/index.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/http-error.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/entities/user.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/interfaces/inputs/create-user-dto.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/user/key.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/user/message.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/default-error.ts"]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/user/index.ts",{"fileContent":"import userErrorKeys from './key';\nimport userErrorMessages from './message';\n\nexport { userErrorKeys, userErrorMessages };\n","resolvedModuleNames":["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/user/key.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/user/message.ts"]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/user/key.ts",{"fileContent":"export default {\n  CREATE_USER_FAIL: 'USER-001',\n  FIND_USER_FAIL: 'USER-002',\n};\n","resolvedModuleNames":[]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/user/message.ts",{"fileContent":"export default {\n  'USER-001': 'Failed to create user.',\n  'USER-002': 'Failed to find user.',\n};\n","resolvedModuleNames":[]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/entities/user.ts",{"fileContent":"import {\n  BaseEntity,\n  BeforeInsert,\n  Column,\n  CreateDateColumn,\n  Entity,\n  PrimaryGeneratedColumn,\n  UpdateDateColumn,\n} from 'typeorm';\nimport * as bcrypt from 'bcryptjs';\n\n@Entity()\nexport default class User extends BaseEntity {\n  @PrimaryGeneratedColumn('uuid', { name: 'id' })\n  id: string;\n\n  @Column({ unique: true })\n  email: string;\n\n  @Column()\n  name: string;\n\n  @Column()\n  password: string;\n\n  @Column({ name: 'created_at' })\n  @CreateDateColumn()\n  createdAt: Date;\n\n  @Column({ name: 'updated_at' })\n  @UpdateDateColumn()\n  updatedAt: Date;\n\n  @BeforeInsert()\n  async hashPassword() {\n    if (this.password) {\n      this.password = await bcrypt.hash(this.password, 8);\n    }\n  }\n\n  async validatePassword(password: string): Promise<boolean> {\n    const isValid = await bcrypt.compare(password, this.password);\n    return isValid;\n  }\n}\n","resolvedModuleNames":[]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/controller.ts",{"fileContent":"import { NextFunction, Request, Response } from 'express';\nimport UserRepository from './repository';\n\nasync function createUser(req: Request, res: Response, next: NextFunction) {\n  try {\n    const repository = new UserRepository();\n    const response = await repository.createUser(req.body);\n    res.status(201).json(response);\n  } catch (error) {\n    next(error);\n  }\n}\n\nexport default {\n  createUser,\n};\n","resolvedModuleNames":["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/repository.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/user/index.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/http-error.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/entities/user.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/interfaces/inputs/create-user-dto.ts"]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/auth/controller.spec.ts",{"fileContent":"import { getMockReq, getMockRes } from '@jest-mock/express';\nimport { faker } from '@faker-js/faker';\nimport Repository from './repository';\nimport controller from './controller';\n\njest.mock('./repository');\n\nconst RepositoryMock = Repository as jest.MockedClass<typeof Repository>;\n\ndescribe('Test auth controller', () => {\n  beforeEach(async () => {\n    RepositoryMock.prototype.createToken.mockRestore();\n  });\n\n  test('Should response 201 when call createToken with sucess', async () => {\n    const authMock = {\n      name: faker.internet.userName(),\n      email: faker.internet.email(),\n      password: faker.internet.password(),\n    };\n\n    const mockRequest = getMockReq({\n      body: authMock,\n    });\n\n    const authResponseMock = {\n      id: faker.datatype.uuid(),\n      name: authMock.name,\n      email: authMock.email,\n      createdAt: faker.datatype.datetime(),\n      updatedAt: faker.datatype.datetime(),\n      access_token: faker.datatype.uuid(),\n    };\n\n    const { res, next } = getMockRes();\n\n    RepositoryMock.prototype.createToken.mockResolvedValue(authResponseMock);\n\n    await controller.createToken(mockRequest, res, next);\n\n    expect(RepositoryMock.prototype.createToken).toBeCalledTimes(1);\n    expect(RepositoryMock.prototype.createToken).toBeCalledWith(authMock);\n    expect(res.status).toBeCalledTimes(1);\n    expect(res.status).toBeCalledWith(201);\n    expect(res.json).toBeCalledTimes(1);\n    expect(next).toBeCalledTimes(0);\n  });\n\n  test('Should return error when call createToken with exception', async () => {\n    const mockRequest = getMockReq();\n\n    const mockError = new Error('Any Error.');\n\n    const { res, next } = getMockRes();\n\n    RepositoryMock.prototype.createToken.mockRejectedValue(mockError);\n\n    await controller.createToken(mockRequest, res, next);\n\n    expect(RepositoryMock.prototype.createToken).toBeCalledTimes(1);\n    expect(res.status).not.toBeCalled();\n    expect(res.json).not.toBeCalled();\n    expect(next).toBeCalledTimes(1);\n    expect(next).toBeCalledWith(mockError);\n  });\n});\n","resolvedModuleNames":["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/auth/repository.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/auth/controller.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/auth/index.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/http-error.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/auth/interfaces/inputs/create-token-dto.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/repository.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/utils/jwt.utils.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/auth/interfaces/outputs/create-token-dto.ts"]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/auth/repository.ts",{"fileContent":"import { authErrorKeys, authErrorMessages } from '../../errors/translator/auth';\nimport HttpError from '../../errors/http-error';\nimport CreateTokenRequest from './interfaces/inputs/create-token-dto';\nimport UserRepository from '../user/repository';\nimport { generateToken } from '../../utils/jwt.utils';\nimport CreateTokenResponse from './interfaces/outputs/create-token-dto';\n\nexport default class AuthRepository {\n  private async validateUser(authData: CreateTokenRequest) {\n    const { email, password } = authData;\n    const userRepository = new UserRepository();\n    const user = await userRepository.findByEmail(email);\n    if (!(await user.validatePassword(password))) {\n      throw new Error();\n    }\n\n    return user;\n  }\n\n  public async createToken(authData: CreateTokenRequest): Promise<CreateTokenResponse> {\n    try {\n      const user = await this.validateUser(authData);\n      delete user.password;\n\n      return {\n        ...user,\n        access_token: generateToken(),\n      };\n    } catch (error) {\n      throw new HttpError(\n        500,\n        authErrorKeys.CREATE_TOKEN_FAIL,\n        authErrorMessages[authErrorKeys.CREATE_TOKEN_FAIL],\n        {},\n      );\n    }\n  }\n}\n","resolvedModuleNames":["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/auth/index.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/http-error.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/auth/interfaces/inputs/create-token-dto.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/repository.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/utils/jwt.utils.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/auth/interfaces/outputs/create-token-dto.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/auth/key.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/auth/message.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/default-error.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/user/index.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/entities/user.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/interfaces/inputs/create-user-dto.ts"]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/auth/index.ts",{"fileContent":"import authErrorKeys from './key';\nimport authErrorMessages from './message';\n\nexport { authErrorKeys, authErrorMessages };\n","resolvedModuleNames":["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/auth/key.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/auth/message.ts"]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/auth/key.ts",{"fileContent":"export default {\n  CREATE_TOKEN_FAIL: 'AUTH-001',\n};\n","resolvedModuleNames":[]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/auth/message.ts",{"fileContent":"export default {\n  'AUTH-001': 'Failed to create token.',\n};\n","resolvedModuleNames":[]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/utils/jwt.utils.ts",{"fileContent":"import {\n  sign, SignOptions, verify, VerifyOptions,\n} from 'jsonwebtoken';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nexport function generateToken() {\n  const privateKey = {\n    key: fs.readFileSync(path.join(__dirname, '../../private.pem')),\n    passphrase: process.env.AUTH_PASSPHRASE,\n  };\n\n  const signInOptions: SignOptions = {\n    algorithm: 'RS256',\n    expiresIn: '24h',\n  };\n\n  return sign({}, privateKey, signInOptions);\n}\n\ninterface TokenPayload {\n  exp: number;\n  accessTypes: string[];\n  name: string;\n  userId: number;\n}\n\nexport function validateToken(token: string): Promise<TokenPayload> {\n  const publicKey = fs.readFileSync(path.join(__dirname, '../../public.pem'));\n\n  const verifyOptions: VerifyOptions = {\n    algorithms: ['RS256'],\n  };\n\n  return new Promise((resolve, reject) => {\n    verify(token, publicKey, verifyOptions, (error, decoded: TokenPayload) => {\n      if (error) return reject(error);\n\n      resolve(decoded);\n    });\n  });\n}\n","resolvedModuleNames":[]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/auth/controller.ts",{"fileContent":"import { NextFunction, Request, Response } from 'express';\nimport AuthRepository from './repository';\n\nasync function createToken(req: Request, res: Response, next: NextFunction) {\n  try {\n    const repository = new AuthRepository();\n    const response = await repository.createToken(req.body);\n    res.status(201).json(response);\n  } catch (error) {\n    next(error);\n  }\n}\n\nexport default {\n  createToken,\n};\n","resolvedModuleNames":["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/auth/repository.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/auth/index.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/http-error.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/auth/interfaces/inputs/create-token-dto.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/repository.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/utils/jwt.utils.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/auth/interfaces/outputs/create-token-dto.ts"]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/repository.spec.ts",{"fileContent":"import { faker } from '@faker-js/faker';\nimport { repositoryMock } from '../../../mocks/typeorm.mock';\nimport UserRepository from './repository';\nimport User from './entities/user';\n\njest.mock('./entities/user');\n\ndescribe('Test user repository', () => {\n  beforeEach(() => {\n    repositoryMock.save.mockRestore();\n    repositoryMock.create.mockRestore();\n    repositoryMock.delete.mockRestore();\n    repositoryMock.findOne.mockRestore();\n  });\n\n  test('Should return user with success', async () => {\n    const userMock = {\n      email: faker.internet.email(),\n    };\n\n    const userResponseMock = {\n      id: faker.datatype.uuid(),\n      name: faker.datatype.string(),\n      email: userMock.email,\n      createdAt: faker.datatype.datetime(),\n      updatedAt: faker.datatype.datetime(),\n    } as User;\n\n    const userRepository = new UserRepository();\n    const createdUser = await userRepository.findByEmail(userMock.email);\n\n    expect(repositoryMock.save).toBeCalledTimes(1);\n    expect(repositoryMock.save).toBeCalledWith(userMock);\n    expect(createdUser).toEqual(userResponseMock);\n  });\n\n  test('Should return error when call create with exception', async () => {\n    const userMock = {\n      name: faker.internet.userName(),\n      email: faker.internet.email(),\n      password: faker.internet.password(),\n    };\n    const mockError = new Error('Any Error.');\n    repositoryMock.save.mockRejectedValue(mockError);\n\n    try {\n      const userRepository = new UserRepository();\n      await userRepository.findByEmail(userMock.email);\n    } catch (error) {\n      expect(repositoryMock.save).toBeCalledTimes(1);\n      expect(repositoryMock.save).toBeCalledWith(userMock);\n      expect(error.code).toEqual('USER-002');\n      expect(error.statusCode).toEqual(500);\n    }\n  });\n});\n","resolvedModuleNames":["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/mocks/typeorm.mock.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/repository.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/entities/user.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/translator/user/index.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/errors/http-error.ts","/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/src/domain/user/interfaces/inputs/create-user-dto.ts"]}],["/home/filippoippolitorodrigues/Área de Trabalho/MYPROJECTS/challenge-full-stack-web/api/mocks/typeorm.mock.ts",{"fileContent":"// eslint-disable-next-line import/no-extraneous-dependencies\nimport { mock, MockProxy } from 'jest-mock-extended';\nimport { Connection, Repository, SelectQueryBuilder } from 'typeorm';\n\nexport const repositoryMock = mock<Repository<any>>();\nexport const connectionMock: MockProxy<Connection> = mock<Connection>();\nexport const selectQueryBuilderMock = mock<SelectQueryBuilder<any>>();\n\njest.mock('typeorm', () => ({\n  getCustomRepository: () => repositoryMock,\n  getRepository: () => repositoryMock,\n  getConnection: () => connectionMock,\n\n  BaseEntity: () => { },\n  Entity: () => () => { },\n  PrimaryColumn: () => () => { },\n  PrimaryGeneratedColumn: () => () => { },\n  Column: () => () => { },\n  CreateDateColumn: () => () => { },\n  UpdateDateColumn: () => () => { },\n  Unique: () => () => { },\n  JoinColumn: () => () => { },\n  JoinTable: () => () => { },\n  OneToOne: () => () => { },\n  OneToMany: () => () => { },\n  ManyToOne: () => () => { },\n  Repository: jest.fn(),\n  EntityRepository: () => () => { },\n}));\n","resolvedModuleNames":[]}]]